Description: Build with libdvbpsi 1.0.0
Origin: backport,
 http://git.videolan.org/?p=vlc.git;a=commit;h=cbe6eace23b5127594f8563d6a0e05c785247a34,
 http://git.videolan.org/?p=vlc.git;a=commit;h=509e832b4d32731ae5b0431e1bdcc75b388794eb,
 http://git.videolan.org/?p=vlc.git;a=commit;h=dfcfb98d7878db2649cbd5137325116e6b77f8a0,
 http://git.videolan.org/?p=vlc.git;a=commit;h=4b2446d41d75bf9936a90befd847d47a91077c2a
Bug-Debian: http://bugs.debian.org/715520
Last-Update: 2013-07-20

diff --git a/modules/access/Modules.am b/modules/access/Modules.am
index ff6047e..1de7a6f 100644
--- a/modules/access/Modules.am
+++ b/modules/access/Modules.am
@@ -194,7 +194,7 @@ if HAVE_LINUX_DVB
 libdtv_plugin_la_SOURCES += dtv/linux.c
 libdtv_plugin_la_CFLAGS += -DHAVE_LINUX_DVB
 if HAVE_DVBPSI
-libdtv_plugin_la_SOURCES += dtv/en50221.c dtv/en50221.h
+libdtv_plugin_la_SOURCES += dtv/en50221.c dtv/en50221.h ../mux/mpeg/dvbpsi_compat.h
 libdtv_plugin_la_CFLAGS += -DHAVE_DVBPSI $(DVBPSI_CFLAGS)
 libdtv_plugin_la_LIBADD += $(DVBPSI_LIBS)
 endif
diff --git a/modules/access/dtv/en50221.c b/modules/access/dtv/en50221.c
index edcc56d..66686c9 100644
--- a/modules/access/dtv/en50221.c
+++ b/modules/access/dtv/en50221.c
@@ -58,6 +58,8 @@
 #include "../demux/dvb-text.h"
 #include "dtv/en50221.h"
 
+#include "../mux/mpeg/dvbpsi_compat.h"
+
 typedef struct en50221_session_t
 {
     unsigned i_slot;
diff --git a/modules/demux/Modules.am b/modules/demux/Modules.am
index 6926361..4bbe872 100644
--- a/modules/demux/Modules.am
+++ b/modules/demux/Modules.am
@@ -64,7 +64,7 @@ libvlc_LTLIBRARIES += \
 	libdemux_stl_plugin.la \
 	$(NULL)
 
-libts_plugin_la_SOURCES = ts.c ../mux/mpeg/csa.c dvb-text.h
+libts_plugin_la_SOURCES = ts.c ../mux/mpeg/csa.c ../mux/mpeg/dvbpsi_compat.h dvb-text.h
 libts_plugin_la_CFLAGS = $(AM_CFLAGS) $(DVBPSI_CFLAGS)
 libts_plugin_la_LIBADD = $(AM_LIBADD) $(DVBPSI_LIBS) $(SOCKET_LIBS)
 libts_plugin_la_DEPENDENCIES =
diff --git a/modules/demux/ts.c b/modules/demux/ts.c
index e7d6f9d..418c7c6 100644
--- a/modules/demux/ts.c
+++ b/modules/demux/ts.c
@@ -67,6 +67,8 @@
 #   include <time.h>
 #endif
 
+#include "../mux/mpeg/dvbpsi_compat.h"
+
 #undef TS_DEBUG
 
 /*****************************************************************************
@@ -407,8 +409,14 @@ static int  PIDFillFormat( ts_pid_t *pid, int i_stream_type );
 
 static void PATCallBack( demux_t *, dvbpsi_pat_t * );
 static void PMTCallBack( demux_t *p_demux, dvbpsi_pmt_t *p_pmt );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+static void PSINewTableCallBack( dvbpsi_t *handle, uint8_t  i_table_id,
+                                 uint16_t i_extension, demux_t * );
+#else
 static void PSINewTableCallBack( demux_t *, dvbpsi_handle,
                                  uint8_t  i_table_id, uint16_t i_extension );
+#endif
+
 static int ChangeKeyCallback( vlc_object_t *, char const *, vlc_value_t, vlc_value_t, void * );
 
 static inline int PIDGet( block_t *p )
@@ -559,6 +567,50 @@ static int DetectPacketSize( demux_t *p_demux )
     return -1;
 }
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+static void vlc_dvbpsi_reset( demux_t *p_demux )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+
+    ts_pid_t *pat = &p_sys->pid[0];
+    ts_pid_t *sdt = &p_sys->pid[0x11];
+    ts_pid_t *eit = &p_sys->pid[0x12];
+    ts_pid_t *tdt = &p_sys->pid[0x14];
+
+    if( pat->psi->handle )
+    {
+        if( dvbpsi_decoder_present( pat->psi->handle ) )
+            dvbpsi_pat_detach( pat->psi->handle );
+        dvbpsi_delete( pat->psi->handle );
+        pat->psi->handle = NULL;
+    }
+
+    if( sdt->psi->handle )
+    {
+        if( dvbpsi_decoder_present( sdt->psi->handle ) )
+            dvbpsi_DetachDemux( sdt->psi->handle );
+        dvbpsi_delete( sdt->psi->handle );
+        sdt->psi->handle = NULL;
+    }
+
+    if( eit->psi->handle )
+    {
+        if( dvbpsi_decoder_present( eit->psi->handle ) )
+            dvbpsi_DetachDemux( eit->psi->handle );
+        dvbpsi_delete( eit->psi->handle );
+        eit->psi->handle = NULL;
+    }
+
+    if( tdt->psi->handle )
+    {
+        if( dvbpsi_decoder_present( tdt->psi->handle ) )
+            dvbpsi_DetachDemux( tdt->psi->handle );
+        dvbpsi_delete( tdt->psi->handle );
+        tdt->psi->handle = NULL;
+    }
+}
+#endif
+
 /*****************************************************************************
  * Open
  *****************************************************************************/
@@ -664,31 +716,81 @@ static int Open( vlc_object_t *p_this )
     p_sys->csa = NULL;
     p_sys->b_start_record = false;
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+# define VLC_DVBPSI_DEMUX_TABLE_INIT(table,obj) \
+    do { \
+        (table)->psi->handle = dvbpsi_new( &dvbpsi_messages, DVBPSI_MSG_DEBUG ); \
+        if( ! (table)->psi->handle ) \
+        { \
+            vlc_mutex_destroy( &p_sys->csa_lock ); \
+            free( p_sys ); \
+            return VLC_ENOMEM; \
+        } \
+        (table)->psi->handle->p_sys = (void *) VLC_OBJECT(obj); \
+        if( !dvbpsi_AttachDemux( (table)->psi->handle, (dvbpsi_demux_new_cb_t)PSINewTableCallBack, (obj) ) ) \
+        { \
+            vlc_dvbpsi_reset( obj ); \
+            vlc_mutex_destroy( &p_sys->csa_lock ); \
+            free( p_sys ); \
+            return VLC_EGENERIC; \
+        } \
+    } while (0);
+#endif
+
     /* Init PAT handler */
     pat = &p_sys->pid[0];
     PIDInit( pat, true, NULL );
-    pat->psi->handle = dvbpsi_AttachPAT( (dvbpsi_pat_callback)PATCallBack,
-                                         p_demux );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+    pat->psi->handle = dvbpsi_new( &dvbpsi_messages, DVBPSI_MSG_DEBUG );
+    if( !pat->psi->handle )
+    {
+        vlc_mutex_destroy( &p_sys->csa_lock );
+        free( p_sys );
+        return VLC_ENOMEM;
+    }
+    pat->psi->handle->p_sys = (void *) p_demux;
+    if( !dvbpsi_pat_attach( pat->psi->handle, PATCallBack, p_demux ) )
+    {
+        vlc_dvbpsi_reset( p_demux );
+        vlc_mutex_destroy( &p_sys->csa_lock );
+        free( p_sys );
+        return VLC_EGENERIC;
+    }
+#else
+    pat->psi->handle = dvbpsi_AttachPAT( PATCallBack, p_demux );
+#endif
     if( p_sys->b_dvb_meta )
     {
         ts_pid_t *sdt = &p_sys->pid[0x11];
         ts_pid_t *eit = &p_sys->pid[0x12];
 
         PIDInit( sdt, true, NULL );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        VLC_DVBPSI_DEMUX_TABLE_INIT( sdt, p_demux )
+#else
         sdt->psi->handle =
             dvbpsi_AttachDemux( (dvbpsi_demux_new_cb_t)PSINewTableCallBack,
                                 p_demux );
+#endif
         PIDInit( eit, true, NULL );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        VLC_DVBPSI_DEMUX_TABLE_INIT( eit, p_demux )
+#else
         eit->psi->handle =
             dvbpsi_AttachDemux( (dvbpsi_demux_new_cb_t)PSINewTableCallBack,
                                 p_demux );
+#endif
 #ifdef TS_USE_TDT
         ts_pid_t *tdt = &p_sys->pid[0x14];
         PIDInit( tdt, true, NULL );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        VLC_DVBPSI_DEMUX_TABLE_INIT( tdt, p_demux )
+#else
         tdt->psi->handle =
             dvbpsi_AttachDemux( (dvbpsi_demux_new_cb_t)PSINewTableCallBack,
                                 p_demux );
 #endif
+#endif
         if( p_sys->b_access_control )
         {
             if( SetPIDFilter( p_demux, 0x11, true ) ||
@@ -700,6 +802,10 @@ static int Open( vlc_object_t *p_this )
         }
     }
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+# undef VLC_DVBPSI_DEMUX_TABLE_INIT
+#endif
+
     /* Init PMT array */
     TAB_INIT( p_sys->i_pmt, p_sys->pmt );
     p_sys->i_pmt_es = 0;
@@ -850,7 +956,14 @@ static void Close( vlc_object_t *p_this )
             switch( pid->i_pid )
             {
             case 0: /* PAT */
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                if( dvbpsi_decoder_present( pid->psi->handle ) )
+                    dvbpsi_pat_detach( pid->psi->handle );
+                dvbpsi_delete( pid->psi->handle );
+                pid->psi->handle = NULL;
+#else
                 dvbpsi_DetachPAT( pid->psi->handle );
+#endif
                 free( pid->psi );
                 break;
             case 1: /* CAT */
@@ -861,6 +974,10 @@ static void Close( vlc_object_t *p_this )
                 {
                     /* SDT or EIT or TDT */
                     dvbpsi_DetachDemux( pid->psi->handle );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                    dvbpsi_delete( pid->psi->handle );
+                    pid->psi->handle = NULL;
+#endif
                     free( pid->psi );
                 }
                 else
@@ -1372,7 +1489,22 @@ static int UserPmt( demux_t *p_demux, const char *psz_fmt )
     prg->i_pid_pmt  = -1;
     prg->i_version  = -1;
     prg->i_number   = i_number != 0 ? i_number : TS_USER_PMT_NUMBER;
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+    prg->handle = dvbpsi_new( &dvbpsi_messages, DVBPSI_MSG_DEBUG );
+    if( !prg->handle )
+        goto error;
+    prg->handle->p_sys = (void *) VLC_OBJECT(p_demux);
+    if( !dvbpsi_pmt_attach( prg->handle,
+                            ((i_number != TS_USER_PMT_NUMBER ? i_number : 1)),
+                            PMTCallBack, p_demux ) )
+    {
+        dvbpsi_delete( prg->handle );
+        prg->handle = NULL;
+        goto error;
+    }
+#else
     prg->handle     = dvbpsi_AttachPMT( i_number != TS_USER_PMT_NUMBER ? i_number : 1, (dvbpsi_pmt_callback)PMTCallBack, p_demux );
+#endif
     TAB_APPEND( pmt->psi->i_prg, pmt->psi->prg, prg );
 
     psz = strchr( psz, '=' );
@@ -1588,13 +1720,30 @@ static void PIDClean( demux_t *p_demux, ts_pid_t *pid )
     if( pid->psi )
     {
         if( pid->psi->handle )
+        {
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+            if( dvbpsi_decoder_present( pid->psi->handle ) )
+                dvbpsi_pmt_detach( pid->psi->handle );
+            dvbpsi_delete( pid->psi->handle );
+            pid->psi->handle = NULL;
+#else
             dvbpsi_DetachPMT( pid->psi->handle );
+#endif
+        }
         for( int i = 0; i < pid->psi->i_prg; i++ )
         {
             if( pid->psi->prg[i]->iod )
                 IODFree( pid->psi->prg[i]->iod );
             if( pid->psi->prg[i]->handle )
+            {
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                if( dvbpsi_decoder_present( pid->psi->prg[i]->handle ) )
+                    dvbpsi_pmt_detach( pid->psi->prg[i]->handle );
+                dvbpsi_delete( pid->psi->prg[i]->handle );
+#else
                 dvbpsi_DetachPMT( pid->psi->prg[i]->handle );
+#endif
+            }
             free( pid->psi->prg[i] );
         }
         free( pid->psi->prg );
@@ -2904,7 +3053,13 @@ static void ValidateDVBMeta( demux_t *p_demux, int i_pid )
         ts_pid_t *p_pid = &p_sys->pid[i];
         if( p_pid->psi )
         {
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+            if( dvbpsi_decoder_present( p_pid->psi->handle ))
+                dvbpsi_DetachDemux( p_pid->psi->handle );
+            dvbpsi_delete( p_pid->psi->handle );
+#else
             dvbpsi_DetachDemux( p_pid->psi->handle );
+#endif
             free( p_pid->psi );
             p_pid->psi = NULL;
             p_pid->b_valid = false;
@@ -2943,7 +3098,12 @@ static void SDTCallBack( demux_t *p_demux, dvbpsi_sdt_t *p_sdt )
 
     msg_Dbg( p_demux, "new SDT ts_id=%d version=%d current_next=%d "
              "network_id=%d",
-             p_sdt->i_ts_id, p_sdt->i_version, p_sdt->b_current_next,
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+             p_sdt->i_extension,
+#else
+             p_sdt->i_ts_id,
+#endif
+             p_sdt->i_version, p_sdt->b_current_next,
              p_sdt->i_network_id );
 
     p_sys->b_broken_charset = false;
@@ -3147,7 +3307,12 @@ static void EITCallBack( demux_t *p_demux,
     msg_Dbg( p_demux, "new EIT service_id=%d version=%d current_next=%d "
              "ts_id=%d network_id=%d segment_last_section_number=%d "
              "last_table_id=%d",
-             p_eit->i_service_id, p_eit->i_version, p_eit->b_current_next,
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+             p_eit->i_extension,
+#else
+             p_eit->i_service_id,
+#endif
+             p_eit->i_version, p_eit->b_current_next,
              p_eit->i_ts_id, p_eit->i_network_id,
              p_eit->i_segment_last_section_number, p_eit->i_last_table_id );
 
@@ -3262,7 +3427,13 @@ static void EITCallBack( demux_t *p_demux,
     {
         if( b_current_following &&
             (  p_sys->i_current_program == -1 ||
-               p_sys->i_current_program == p_eit->i_service_id ) )
+               p_sys->i_current_program ==
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                    p_eit->i_extension
+#else
+                    p_eit->i_service_id
+#endif
+                ) )
         {
             p_sys->i_dvb_length = 0;
             p_sys->i_dvb_start = 0;
@@ -3273,7 +3444,13 @@ static void EITCallBack( demux_t *p_demux,
                 p_sys->i_dvb_length = CLOCK_FREQ * p_epg->p_current->i_duration;
             }
         }
-        es_out_Control( p_demux->out, ES_OUT_SET_GROUP_EPG, p_eit->i_service_id, p_epg );
+        es_out_Control( p_demux->out, ES_OUT_SET_GROUP_EPG,
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                        p_eit->i_extension,
+#else
+                        p_eit->i_service_id,
+#endif
+                        p_epg );
     }
     vlc_epg_Delete( p_epg );
 
@@ -3288,9 +3465,15 @@ static void EITCallBackSchedule( demux_t *p_demux, dvbpsi_eit_t *p_eit )
     EITCallBack( p_demux, p_eit, false );
 }
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+static void PSINewTableCallBack( dvbpsi_t *h, uint8_t i_table_id,
+                                 uint16_t i_extension, demux_t *p_demux )
+#else
 static void PSINewTableCallBack( demux_t *p_demux, dvbpsi_handle h,
                                  uint8_t  i_table_id, uint16_t i_extension )
+#endif
 {
+    assert( h );
 #if 0
     msg_Dbg( p_demux, "PSINewTableCallBack: table 0x%x(%d) ext=0x%x(%d)",
              i_table_id, i_table_id, i_extension, i_extension );
@@ -3299,9 +3482,14 @@ static void PSINewTableCallBack( demux_t *p_demux, dvbpsi_handle h,
     {
         msg_Dbg( p_demux, "PSINewTableCallBack: table 0x%x(%d) ext=0x%x(%d)",
                  i_table_id, i_table_id, i_extension, i_extension );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        if( !dvbpsi_sdt_attach( h, i_table_id, i_extension, (dvbpsi_sdt_callback)SDTCallBack, p_demux ) )
+            msg_Err( p_demux, "PSINewTableCallback: failed attaching SDTCallback" );
+#else
 
         dvbpsi_AttachSDT( h, i_table_id, i_extension,
                           (dvbpsi_sdt_callback)SDTCallBack, p_demux );
+#endif
     }
     else if( p_demux->p_sys->pid[0x11].psi->i_sdt_version != -1 &&
              ( i_table_id == 0x4e || /* Current/Following */
@@ -3313,7 +3501,12 @@ static void PSINewTableCallBack( demux_t *p_demux, dvbpsi_handle h,
         dvbpsi_eit_callback cb = i_table_id == 0x4e ?
                                     (dvbpsi_eit_callback)EITCallBackCurrentFollowing :
                                     (dvbpsi_eit_callback)EITCallBackSchedule;
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        if( !dvbpsi_eit_attach( h, i_table_id, i_extension, cb, p_demux ) )
+            msg_Err( p_demux, "PSINewTableCallback: failed attaching EITCallback" );
+#else
         dvbpsi_AttachEIT( h, i_table_id, i_extension, cb, p_demux );
+#endif
     }
 #ifdef TS_USE_TDT
     else if( p_demux->p_sys->pid[0x11].psi->i_sdt_version != -1 &&
@@ -3321,8 +3514,13 @@ static void PSINewTableCallBack( demux_t *p_demux, dvbpsi_handle h,
     {
          msg_Dbg( p_demux, "PSINewTableCallBack: table 0x%x(%d) ext=0x%x(%d)",
                  i_table_id, i_table_id, i_extension, i_extension );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        if( !dvbpsi_tot_attach( h, i_table_id, i_extension, (dvbpsi_tot_callback)TDTCallBack, p_demux ) )
+            msg_Err( p_demux, "PSINewTableCallback: failed attaching TDTCallback" );
+#else
          dvbpsi_AttachTOT( h, i_table_id, i_extension,
                            (dvbpsi_tot_callback)TDTCallBack, p_demux);
+#endif
     }
 #endif
 
@@ -3489,7 +3687,7 @@ static void PMTSetupEsTeletext( demux_t *p_demux, ts_pid_t *pid,
 
     /* Gather pages information */
 #if defined _DVBPSI_DR_56_H_ && \
-    defined DVBPSI_VERSION && DVBPSI_VERSION_INT > ((0<<16)+(1<<8)+5)
+    defined DVBPSI_VERSION && DVBPSI_VERSION_INT > DVBPSI_VERSION_WANTED(0,1,5)
     for( unsigned i_tag_idx = 0; i_tag_idx < 2; i_tag_idx++ )
     {
         dvbpsi_descriptor_t *p_dr = PMTEsFindDescriptor( p_es, i_tag_idx == 0 ? 0x46 : 0x56 );
@@ -4503,10 +4701,23 @@ static void PATCallBack( demux_t *p_demux, dvbpsi_pat_t *p_pat )
             if( b_add )
             {
                 PIDInit( pmt, true, pat->psi );
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                pmt->psi->prg[pmt->psi->i_prg-1]->handle = dvbpsi_new( &dvbpsi_messages, DVBPSI_MSG_DEBUG );
+                if( !pmt->psi->prg[pmt->psi->i_prg-1]->handle )
+                {
+                    dvbpsi_DeletePAT( p_pat );
+                    return;
+                }
+                pmt->psi->prg[pmt->psi->i_prg-1]->handle->p_sys = (void *) VLC_OBJECT(p_demux);
+                if( !dvbpsi_pmt_attach( pmt->psi->prg[pmt->psi->i_prg-1]->handle, p_program->i_number, PMTCallBack, p_demux ) )
+                    msg_Err( p_demux, "PATCallback failed attaching PMTCallback to program %d",
+                             p_program->i_number );
+#else
                 pmt->psi->prg[pmt->psi->i_prg-1]->handle =
                     dvbpsi_AttachPMT( p_program->i_number,
                                       (dvbpsi_pmt_callback)PMTCallBack,
                                       p_demux );
+#endif
                 pmt->psi->prg[pmt->psi->i_prg-1]->i_number =
                     p_program->i_number;
                 pmt->psi->prg[pmt->psi->i_prg-1]->i_pid_pmt =
diff --git a/modules/mux/Modules.am b/modules/mux/Modules.am
index b166cf3..eeb0e7a 100644
--- a/modules/mux/Modules.am
+++ b/modules/mux/Modules.am
@@ -19,7 +19,7 @@ libvlc_LTLIBRARIES += \
 libmux_ts_plugin_la_SOURCES = \
 	mpeg/pes.c mpeg/pes.h \
 	mpeg/csa.c mpeg/csa.h \
-	mpeg/ts.c mpeg/bits.h
+	mpeg/ts.c mpeg/bits.h mpeg/dvbpsi_compat.h
 libmux_ts_plugin_la_CFLAGS = $(AM_CFLAGS) $(DVBPSI_CFLAGS)
 libmux_ts_plugin_la_LIBADD = $(AM_LIBADD) $(DVBPSI_LIBS)
 libmux_ts_plugin_la_DEPENDENCIES =
diff --git a/modules/mux/mpeg/dvbpsi_compat.h b/modules/mux/mpeg/dvbpsi_compat.h
new file mode 100644
index 0000000..6f68cfd
--- /dev/null
+++ b/modules/mux/mpeg/dvbpsi_compat.h
@@ -0,0 +1,82 @@
+/*****************************************************************************
+ * dvbpsi_compat.h: Compatibility headerfile
+ *****************************************************************************
+ * Copyright (C) 2013 VideoLAN Association
+ *
+ * Authors: Jean-Paul Saman <jpsaman@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef DVBPSI_COMPAT_H
+#define DVBPSI_COMPAT_H
+
+/*
+ * dvbpsi compatibility macros:
+ * dvbpsi version 1.0.0 and above returns a struct 'dvbpsi_t' as handle
+ */
+#define DVBPSI_VERSION_WANTED(major,minor,bugfix) (((major)<<16)+((minor)<<8)+(bugfix))
+
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+# define dvbpsi_handle dvbpsi_t*
+# define dvbpsi_PushPacket(handle,data) dvbpsi_packet_push((handle),(data))
+/* PAT */
+# define dvbpsi_InitPAT(pat,id,version,next) dvbpsi_pat_init((pat),(id),(version),(bool)(next))
+# define dvbpsi_PATAddProgram(pat,nr,pid)    dvbpsi_pat_program_add((pat),(nr),(pid))
+# define dvbpsi_EmptyPAT(pat)                dvbpsi_pat_empty((pat))
+# define dvbpsi_DeletePAT(table)             dvbpsi_pat_delete((table))
+# define dvbpsi_DetachPAT(pat)               dvbpsi_pat_detach((pat))
+/* PMT */
+# define dvbpsi_InitPMT(pmt,program,version,next,pcr) \
+         dvbpsi_pmt_init((pmt),(program),(version),(bool)(next),(pcr))
+# define dvbpsi_PMTAddDescriptor(pmt,tag,length,data) \
+         dvbpsi_pmt_descriptor_add((pmt),(tag),(length),(data))
+# define dvbpsi_PMTAddES(pmt,type,pid) \
+         dvbpsi_pmt_es_add((pmt),(type),(pid))
+# define dvbpsi_PMTESAddDescriptor(es,tag,length,data) \
+         dvbpsi_pmt_es_descriptor_add((es),(tag),(length),(data))
+# define dvbpsi_EmptyPMT(pmt) dvbpsi_pmt_empty((pmt))
+# define dvbpsi_DeletePMT(table)        dvbpsi_pmt_delete((table))
+# define dvbpsi_DetachPMT(pmt)          dvbpsi_pmt_detach((pmt))
+/* SDT */
+# define dvbpsi_InitSDT(sdt,id,version,curnext,netid) \
+         dvbpsi_sdt_init((sdt),(id),(0),(version),(bool)(curnext),(netid))
+# define dvbpsi_SDTAddService(sdt,id,schedule,present,status,ca) \
+         dvbpsi_sdt_service_add((sdt),(id),(bool)(schedule),(bool)(present),(status),(bool)(ca))
+# define dvbpsi_EmptySDT(sdt) dvbpsi_sdt_empty((sdt))
+# define dvbpsi_DeleteSDT(table)        dvbpsi_sdt_delete((table))
+/* TOT */
+# define dvbpsi_DeleteTOT(table)        dvbpsi_tot_delete((table))
+/* EIT */
+# define dvbpsi_DeleteEIT(table)        dvbpsi_eit_delete((table))
+/* NIT */
+# define dvbpsi_DeleteNIT(table)        dvbpsi_nit_delete((table))
+
+static void dvbpsi_messages(dvbpsi_t *p_dvbpsi, const dvbpsi_msg_level_t level, const char* msg)
+{
+    vlc_object_t *obj = (vlc_object_t *)p_dvbpsi->p_sys;
+
+    /* See dvbpsi.h for the definition of these log levels.*/
+    switch(level)
+    {
+        case DVBPSI_MSG_ERROR: msg_Err( obj, "%s", msg ); break;
+        case DVBPSI_MSG_WARN:  msg_Warn( obj, "%s", msg ); break;
+        case DVBPSI_MSG_DEBUG: msg_Dbg( obj, "%s", msg ); break;
+        default: msg_Info( obj, "%s", msg ); break;
+    }
+}
+#endif
+
+#endif
diff --git a/modules/mux/mpeg/ts.c b/modules/mux/mpeg/ts.c
index 8072ae1..057e967 100644
--- a/modules/mux/mpeg/ts.c
+++ b/modules/mux/mpeg/ts.c
@@ -55,6 +55,8 @@
 # include <dvbpsi/dr.h>
 # include <dvbpsi/psi.h>
 
+#include "dvbpsi_compat.h"
+
 /*
  * TODO:
  *  - check PCR frequency requirement
@@ -364,6 +366,9 @@ struct sout_mux_sys_t
     int             i_audio_bound;
     int             i_video_bound;
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+    dvbpsi_t        *p_dvbpsi;
+#endif
     bool            b_es_id_pid;
     bool            b_sdt;
     int             i_pid_video;
@@ -514,6 +519,16 @@ static int Open( vlc_object_t *p_this )
     p_sys->i_audio_bound = 0;
     p_sys->i_video_bound = 0;
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+    p_sys->p_dvbpsi = dvbpsi_new( &dvbpsi_messages, DVBPSI_MSG_DEBUG );
+    if( !p_sys->p_dvbpsi )
+    {
+        free( p_sys );
+        return VLC_ENOMEM;
+    }
+    p_sys->p_dvbpsi->p_sys = (void *) p_mux;
+#endif
+
     p_sys->b_es_id_pid = var_GetBool( p_mux, SOUT_CFG_PREFIX "es-id-pid" );
 
     var_Get( p_mux, SOUT_CFG_PREFIX "muxpmt", &val );
@@ -839,6 +854,11 @@ static void Close( vlc_object_t * p_this )
     sout_mux_sys_t      *p_sys = p_mux->p_sys;
     int i;
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+    if( p_sys->p_dvbpsi )
+        dvbpsi_delete( p_sys->p_dvbpsi );
+#endif
+
     if( p_sys->csa )
     {
         var_DelCallback( p_mux, SOUT_CFG_PREFIX "csa-ck", ChangeKeyCallback, NULL );
@@ -2322,6 +2342,11 @@ static block_t *WritePSISection( sout_instance_t *p_sout,
     }
 
     return( p_first );
+
+error:
+    if( p_first )
+        block_ChainRelease( p_first );
+    return NULL;
 }
 
 static void GetPAT( sout_mux_t *p_mux,
@@ -2341,9 +2366,12 @@ static void GetPAT( sout_mux_t *p_mux,
                               p_sys->i_pmt_program_number[i],
                               p_sys->pmt[i].i_pid );
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+    p_section = dvbpsi_pat_sections_generate( p_sys->p_dvbpsi, &pat, 0 );
+#else
     p_section = dvbpsi_GenPATSections( &pat,
                                        0 );     /* max program per section */
-
+#endif
     p_pat = WritePSISection( p_mux->p_sout, p_section );
 
     PEStoTS( p_mux->p_sout, c, p_pat, &p_sys->pat );
@@ -2435,9 +2463,16 @@ static void GetPMT( sout_mux_t *p_mux, sout_buffer_chain_t *c )
                     memcpy( &psz_sdt_desc[3+strlen(psz_sdtprov)], psz_sdtserv,
                             strlen(psz_sdtserv) );
 
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+                    dvbpsi_sdt_service_descriptor_add( p_service, 0x48,
+                            (3 + strlen(psz_sdtprov) + strlen(psz_sdtserv)),
+                            (uint8_t *)psz_sdt_desc );
+#else
+
                     dvbpsi_SDTServiceAddDescriptor( p_service, 0x48,
                             3 + strlen(psz_sdtprov) + strlen(psz_sdtserv),
                             (uint8_t *)psz_sdt_desc );
+#endif
                     free( psz_sdt_desc );
                     psz_sdt_desc = NULL;
                 }
@@ -2739,7 +2774,11 @@ static void GetPMT( sout_mux_t *p_mux, sout_buffer_chain_t *c )
 
     for( i = 0; i < p_sys->i_num_pmt; i++ )
     {
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        p_section[i] = dvbpsi_pmt_sections_generate( p_sys->p_dvbpsi, &p_sys->dvbpmt[i] );
+#else
         p_section[i] = dvbpsi_GenPMTSections( &p_sys->dvbpmt[i] );
+#endif
         p_pmt[i] = WritePSISection( p_mux->p_sout, p_section[i] );
         PEStoTS( p_mux->p_sout, c, p_pmt[i], &p_sys->pmt[i] );
         dvbpsi_DeletePSISections( p_section[i] );
@@ -2748,7 +2787,11 @@ static void GetPMT( sout_mux_t *p_mux, sout_buffer_chain_t *c )
 
     if( p_sys->b_sdt )
     {
+#if (DVBPSI_VERSION_INT >= DVBPSI_VERSION_WANTED(1,0,0))
+        p_section2 = dvbpsi_sdt_sections_generate( p_sys->p_dvbpsi, &sdt );
+#else
         p_section2 = dvbpsi_GenSDTSections( &sdt );
+#endif
         p_sdt = WritePSISection( p_mux->p_sout, p_section2 );
         PEStoTS( p_mux->p_sout, c, p_sdt, &p_sys->sdt );
         dvbpsi_DeletePSISections( p_section2 );
